using System.Collections.Generic;

namespace Entitas {

    public delegate void PoolChanged<TEntity>(Pool<TEntity> pool, TEntity entity) where TEntity : class, IEntity, new();
    public delegate void GroupChanged<TEntity>(Pool<TEntity> pool, Group<TEntity> group) where TEntity : class, IEntity, new();

    public interface IPool<TEntity> where TEntity : class, IEntity, new() {

        /// Occurs when an entity gets created.
        event PoolChanged<TEntity> OnEntityCreated;

        /// Occurs when an entity will be destroyed.
        event PoolChanged<TEntity> OnEntityWillBeDestroyed;

        /// Occurs when an entity got destroyed.
        event PoolChanged<TEntity> OnEntityDestroyed;

        /// Occurs when a group gets created for the first time.
        event GroupChanged<TEntity> OnGroupCreated;

        /// Occurs when a group gets cleared.
        event GroupChanged<TEntity> OnGroupCleared;

        /// The total amount of components an entity can possibly have.
        /// This value is generated by the code generator, e.g ComponentIds.TotalComponents.
        int totalComponents { get; }

        /// Returns all componentPools. componentPools is used to reuse removed components.
        /// Removed components will be pushed to the componentPool.
        /// Use entity.CreateComponent(index, type) to get a new or reusable component from the componentPool.
        Stack<IComponent>[] componentPools { get; }

        /// The metaData contains information about the pool.
        /// It's used to provide better error messages.
        PoolMetaData metaData { get; }

        /// Returns the number of entities in the pool.
        int count { get; }

        /// Returns the number of entities in the internal ObjectPool for entities which can be reused.
        int reusableEntitiesCount { get; }

        /// Returns the number of entities that are currently retained by other objects (e.g. Group, GroupObserver, ReactiveSystem).
        int retainedEntitiesCount { get; }

        /// Creates a new entity or gets a reusable entity from the internal ObjectPool for entities.
        TEntity CreateEntity();

        /// Destroys the entity, removes all its components and pushs it back to the internal ObjectPool for entities.
        void DestroyEntity(TEntity entity);

        /// Destroys all entities in the pool.
        /// Throws an exception if there are still retained entities.
        void DestroyAllEntities();

        /// Determines whether the pool has the specified entity.
        bool HasEntity(TEntity entity);

        /// Returns all entities which are currently in the pool.
        TEntity[] GetEntities();

        /// Returns a group for the specified matcher.
        /// Calling pool.GetGroup(matcher) with the same matcher will always return the same instance of the group.
        Group<TEntity> GetGroup(IMatcher<TEntity> matcher);

        /// Clears all groups. This is useful when you want to soft-restart your application.
        void ClearGroups();

        /// Adds the IEntityIndex for the specified name. There can only be one IEntityIndex per name.
        void AddEntityIndex(string name, IEntityIndex entityIndex);

        /// Gets the IEntityIndex for the specified name.
        IEntityIndex GetEntityIndex(string name);

        /// Deactivates all entity indices.
        void DeactivateEntityIndices();

        /// Resets the creationIndex back to 0.
        void ResetCreationIndex();

        /// Clears the componentPool at the specified index.
        void ClearComponentPool(int index);

        /// Clears all componentPools.
        void ClearComponentPools();

        /// Resets the pool (clears all groups, destroys all entities and resets creationIndex back to 0).
        void Reset();

        string ToString();
    }
}